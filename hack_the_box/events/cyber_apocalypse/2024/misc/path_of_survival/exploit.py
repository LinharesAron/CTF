import heapq

class Node:
    def __init__(self, node, parent=None):
        self.position = (node[0], node[1])
        self.parent = parent
        self.type = node[2]
        self.g = 0
        self.h = 0
        self.f = 0

    def __lt__(self, other):
        return self.f < other.f

def cost_rules(current, neighbor):
    if current.type == neighbor.type:
        return 1

    if current.type in "CG":
        return 1

    if neighbor.type in "CG":
        return 1

    rule = current.type+neighbor.type
    return {
        "PM": 5,
        "MP": 2,
        "PS": 2,
        "SP": 2,
        "PR": 5,
        "RP": 5,
        "MS": 5,
        "SM": 7,
        "MR": 8,
        "RM": 10,
        "SR": 8,
        "RS": 6
    }[rule]

def direction(path):
    direction = []
    for i in range(len(path) - 1):
        if path[i][1] < path[i+1][1]:
            direction.append("R")
        elif path[i][1] > path[i+1][1]:
            direction.append("L")
        
        if path[i][0] < path[i+1][0]:
            direction.append("D")
        elif path[i][0] > path[i+1][0]:
            direction.append("U")
    return direction

def astar(grid, start, goal):
    open_set = []
    closed_set = set()

    start_node = Node(start)
    goal_node = Node(goal)

    heapq.heappush(open_set, start_node)

    while open_set:
        current_node = heapq.heappop(open_set)

        if current_node.position == goal_node.position:
            path = []
            cost = 0
            while current_node:
                path.append(current_node.position)
                cost += current_node.g
                current_node = current_node.parent
            return cost, direction(path[::-1])

        closed_set.add(current_node.position)

        for neighbor in get_neighbors(grid, current_node):
            if neighbor[:-1] in closed_set:
                continue

            neighbor_node = Node(neighbor, current_node)

            g = current_node.g + cost_rules(current_node, neighbor_node)
            h = heuristic(neighbor, goal_node.position)
            f = g + h

            if neighbor_node in open_set and f >= neighbor_node.f:
                continue

            if neighbor_node not in open_set or f < neighbor_node.f:
                neighbor_node.g = g
                neighbor_node.h = h
                neighbor_node.f = f
                heapq.heappush(open_set, neighbor_node)

    return 10000, None

def canGo(current, neighbor):
    cx, cy = current.position
    (nx, ny, ntype) = neighbor

    if ntype == "E":
        return False
    elif ntype == "C" and (cy > ny or cx > nx):
        return False
    elif ntype == "G" and (cy < ny or cx < nx):
        return False
    
    return True

def get_neighbors(grid, node):
    position = node.position
    neighbors = []
    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]

    for dx, dy in directions:
        new_position = (position[0] + dx, position[1] + dy)
        if 0 <= new_position[0] < len(grid) and 0 <= new_position[1] < len(grid[0]) and canGo(node, grid[new_position[0]][new_position[1]]):
            neighbors.append(grid[new_position[0]][new_position[1]])

    return neighbors

def heuristic(a, b):
    return abs(a[0] - b[0]) + abs(a[1] - b[1])

import requests
import math

def loadMap():
    response = requests.post(url + "/map")
    json = response.json()
    player_position = (json["player"]["position"][0], json["player"]["position"][1])
    max_movement = json["player"]["time"]

    height = json["height"]
    width = json["width"]

    tiles = json["tiles"]

    grid = []
    goals = []
    start = (player_position[1], player_position[0], tiles[f"({player_position[0]}, {player_position[1]})"]["terrain"])
    for x in range(height):
        line = []
        for y in range(width):
            t = tiles[f"({y}, {x})"]
            terrain = (x, y, t["terrain"])
            line.append(terrain)
            if t["has_weapon"]:
                goals.append((math.dist([start[0], start[1]], [x,y]),terrain))
        grid.append(line)
    
    return grid, start, goals, max_movement

def update(direction):
    data = {
        "direction": direction 
    }
    response = requests.post(url=url + "/update", json=data)
    json = response.json()
    print(json)
    if "solved" in json:
        return True, json["maps_solved"]
    return False, 0

url = "http://{SERVER}:{PORT}"

solves = 0
while solves < 100:
    grid, start, goals, max_movement = loadMap()
    small = 10000
    best_path = None
    for goal in sorted(goals, key=lambda x: x[0]):
        d, goal = goal
        cost, path = astar(grid, start, goal)
        if cost < small:
            small = cost
            best_path = path

    for p in best_path:
        success, s = update(p)
        if success:
            solves = s
        
